{"meta":{"title":"君君教程网","subtitle":"叶尼水的技术博客","description":"前端、移动端、服务端最全面的开发教程","author":"JinXing Zhong","url":"http://junjun.vip","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-05T08:41:04.662Z","updated":"2019-07-05T06:53:55.270Z","comments":false,"path":"/404.html","permalink":"http://junjun.vip//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-05T09:02:37.175Z","updated":"2019-07-05T09:02:37.175Z","comments":false,"path":"about/index.html","permalink":"http://junjun.vip/about/index.html","excerpt":"","text":"做爱做的事，编想编的程"},{"title":"书单","date":"2019-07-05T08:41:14.818Z","updated":"2019-07-05T06:53:55.271Z","comments":false,"path":"books/index.html","permalink":"http://junjun.vip/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-05T08:40:40.088Z","updated":"2019-07-05T06:53:55.272Z","comments":false,"path":"categories/index.html","permalink":"http://junjun.vip/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-07-05T08:40:40.071Z","updated":"2019-07-05T06:53:55.272Z","comments":true,"path":"links/index.html","permalink":"http://junjun.vip/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-05T08:40:40.054Z","updated":"2019-07-05T06:53:55.272Z","comments":false,"path":"repository/index.html","permalink":"http://junjun.vip/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-05T08:40:40.033Z","updated":"2019-07-05T06:53:55.272Z","comments":false,"path":"tags/index.html","permalink":"http://junjun.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"经典编程书籍大全","slug":"经典编程书籍大全","date":"2019-07-05T16:00:00.000Z","updated":"2019-07-05T17:37:02.305Z","comments":true,"path":"2019/07/06/经典编程书籍大全/","link":"","permalink":"http://junjun.vip/2019/07/06/经典编程书籍大全/","excerpt":"","text":"100+ 经典技术书籍，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试 和 编程相关的经典书籍。 这个列表综合了伯乐在线网站以往推荐经典书籍文章中的列表，以及在微信和微博中被广泛推荐的好书。虽然已经包括了100多本，覆盖的面也比较全。仍然有很多方面需要补充，而且相信还有很多没有被收录的好书。欢迎大家在 issues 中推荐或自荐。 计算机系统与网络 《图灵的秘密:他的生平、思想及论文解读》 《计算机系统概论》 《深入理解Linux内核》 《深入Linux内核架构》 《TCP/IP详解 卷1：协议》 《Linux系统编程（第2版）》 《Linux内核设计与实现（第3版）》 《深入理解计算机系统（原书第3版）》 《计算机程序的构造和解释（原书第2版）》 《编码：隐匿在计算机软硬件背后的语言》 《性能之颠：洞悉系统、企业与云计算》 《UNIX网络编程 卷1：套接字联网API（第3版）》 《UNIX网络编程 卷2：进程间通信》 《Windows核心编程(第5版)》 《WireShark网络分析就这么简单》 《WireShark网络分析的艺术》 编程通用 《设计原本》 《编程原本》 《代码大全》 《UNIX编程艺术》 《代码整洁之道》 《编程珠玑（第2版）》 《编程珠玑（续）》 《软件调试的艺术》 《修改代码的艺术》 《编程语言实现模式》 《编写可读代码的艺术》 《解析极限编程：拥抱变化》 《精通正则表达式（第3版）》 《编译原理（第2版）》龙书 《重构：改善既有代码的设计》 《七周七语言：理解多种编程范型》 《调试九法：软硬件错误的排查之道》 《程序设计语言：实践之路（第3版）》 《计算的本质：深入剖析程序和计算机》 《设计模式 : 可复用面向对象软件的基础》 《Head First 设计模式（中文版） 》（感谢@Great-Li-Xin 推荐 ） 算法与数据结构 《算法（第4版）》 《算法导论（原书第2版）》 《Python算法教程》 《算法设计与分析基础（第3版）》 《学习 JavaScript 数据结构与算法》 《数据结构与算法分析 : C++描述（第4版）》 《数据结构与算法分析 : C语言描述（第2版）》 《数据结构与算法分析 : Java语言描述（第2版）》 职业修炼与规划 《大教堂与集市》 《卓有成效的程序员》 《程序员的职业素养》 《程序员修炼之道：从小工到专家》 《软件开发者路线图：从学徒到高手》 《我编程，我快乐: 程序员职业规划之道》 《程序员的思维修炼：开发认知潜能的九堂课》 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 大师访谈 《编程大师智慧》 《编程大师访谈录》 《编程人生 : 15位软件先驱访谈录》 《奇思妙想 : 15位计算机天才及其重大发现》 《图灵和ACM图灵奖》 架构/性能 《架构即未来》 《微服务设计》 《大数据日知录》 《企业应用架构模式》 《Web性能权威指南》 《SRE：Google运维解密》 《发布！软件的设计与部署》 《高扩展性网站的 50 条原则》 《大型网站技术架构:核心原理与案例分析》 《恰如其分的软件架构：风险驱动的设计方法》 《软件系统架构：使用视点和视角与利益相关者合作（第2版）》 Linux / Unix 《Linux/Unix 系统编程手册》（感谢@geekgao 的推荐） 《Unix 环境高级编程(第3版)》 《Unix/Linux 编程实践教程》 《鸟哥的 Linux 私房菜（基础学习篇）》和《鸟哥的 Linux 私房菜（服务器架设篇）》 《Linux 命令行与 shell 脚本编程大全（第3版）》 《只是为了好玩 : Linux 之父林纳斯自传》 Web前端 《高性能 JavaScript》 《锋利的 jQuery（第2版）》 《JavaScript 忍者秘籍》（感谢@joker-danta 补充推荐） 《编写可维护的 JavaScript》 《你不知道的 JavaScript（上）》 《你不知道的 JavaScript（中）》 《JavaScript 权威指南（第6版）》 《JavaScript 语言精粹（修订版）》 《JavaScript DOM编程艺术 （第2版）》 《JavaScript 高级程序设计（第3版）》 《JavaScript 异步编程：设计快速响应的网络应用》 《JavaScript设计模式与开发实践》 《JavaScript框架设计（第2版）》 《Effective JavaScript：编写高质量JavaScript代码的68个有效方法》 《HTML5 权威指南》 《HTML5 秘籍（第2版）》 《HTML5 与 CSS3 基础教程（第八版）》 《CSS 揭秘》 《CSS 设计指南（第3版）》 《CSS 权威指南（第3版）》 《深入浅出 HTML 与 CSS》 《ES6 标准入门（第三版）》 《深入理解 ES6》 Java开发 《Java8 实战》 《Java并发编程实战》 《Java性能权威指南》 《Java程序员修炼之道》 《实战Java高并发程序设计》 《Java编程思想 （第4版）》 《深入理解Java虚拟机（第2版）》 《Effective java 中文版（第2版）》 《Java核心技术·卷1：基础知识（原书第9版）》 《Java核心技术·卷2：高级特性（原书第9版）》 .NET/.NET Core 《C# 6.0 本质论》 《果壳中的C#：C#5.0权威指南》 《你必须知道的.NET（第2版）》 《深入理解C#（第3版）》 《Effective C#: 50 Specific Ways to Improve Your C#, Third Edition》 《More Effective C# (Includes Content Update Program): 50 Specific Ways to Improve Your C#, 2nd edition》 《Async in C# 5.0: Unleash the Power of Async》 《C#并发编程经典实例》 《C#多线程编程实战(原书第2版)》 《CLR via C#（第4版）》 《.NET本质论 第1卷:公共语言运行库》 《.NET探秘 : MSIL权威指南》 《Pro .NET Performance》 《Shared Source CLI Essentials》 《.NET 高级调试》 《Microsoft.NET 和 Windows 应用程序调试》 《微软.NET 程序的加密与解密》 《.NET Development Using the Compiler API》 《.NET设计规范 : 约定、惯用法与模式》 《编写高性能的.NET代码》 《Building Microservices with .NET Core》 《Microservices in .NET Core, with Examples in NancyFX》 Python 《集体智慧编程》 《笨办法学Python》 《Python基础教程》 《Python源码剖析》 《Head First Python》 《与孩子一起学编程》 《Python学习手册（第4版）》 《Python Cookbook（第3版）》 《Python参考手册（第4版）》 《Python核心编程（第3版）》 《Python科学计算（第2版）》 《利用 Python 进行数据分析》 《Think Python：像计算机科学家一样思考Python（第2版）》 《Python编程实战:运用设计模式、并发和程序库创建高质量程序》 《Python绝技：运用Python成为顶级黑客》 《Flask Web开发:基于Python的Web应用开发实战》 Android 《Android编程权威指南（第2版）》 《移动应用UI设计模式（第2版）》 《Android开发艺术探索》 iOS 《iOS编程实战》 《iOS编程（第4版）》 《Objective-C高级编程》 《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》 PHP 《Head First PHP &amp; MySQL（中文版）》 《深入PHP：面向对象、模式与实践（第3版）》 C语言 《C标准库》 《C和指针》 《C专家编程》 《C陷阱与缺陷》 《C语言接口与实现》 《C程序设计语言（第2版）》 《C语言参考手册（第5版）》 C++ 《C++标准库》 《C++编程思想》 《C++语言的设计与演化》 《C++程序设计原理与实践》 《C++ Primer （中文第5版）》 《C++ Primer习题集(第5版) 》 《C++程序设计语言(第1-3部分)(原书第4版) 》 《Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) 》 《More Effective C++:35个改善编程与设计的有效方法(中文版) 》&nbsp; 机器学习和数据挖掘 《数据之巅》 《矩阵分析》 《机器学习》 《统计学习方法》 《机器学习导论》 《推荐系统实践》 《机器学习实战》 《Web数据挖掘》 《深入浅出统计学》 《模式分类（第2版）》 《概率论与数理统计》 《统计学习基础(第2版)(英文) 》 《数据挖掘：概念与技术（第3版）》 《数据挖掘：实用机器学习工具与技术（原书第3版）》 《大数据：互联网大规模数据挖掘与分布式处理（第2版）》 数据库 《数据库系统概念》 感谢@noisnemid 推荐 《数据库系统实现》 《SQL应用重构》 《SQL Cookbook》 《高性能MySQL （第3版）》 《深入浅出SQL（中文版）》 《MySQL技术内幕 : InnoDB存储引擎（第2版）》 《深入浅出MySQL : 数据库开发、优化与管理维护》 《收获,不止SQL优化:抓住SQL的本质》 《SQL Server 性能优化与管理的艺术》 《SQL Server性能调优实战》 《T-SQL性能调优秘笈:基于SQL Server 2012窗口函数》 测试 《探索式软件测试》 《有效的单元测试》 《Google软件测试之道》 项目与团队 《人月神话》 《快速软件开发》 《人件（原书第3版）》 《门后的秘密：卓越管理的故事》 《极客与团队：软件工程师的团队生存秘笈》 《硝烟中的 Scrum 和 XP》 (感谢@geekgao 的推荐。 求职面试 《程序员面试金典（第5版）》 《编程之美 : 微软技术面试心得》 《金领简历：敲开苹果、微软、谷歌的大门》 《剑指Offer：名企面试官精讲典型编程题（纪念版）》 编程之外 《暗时间》 《数学之美》 《赢得朋友》 《精益创业》 《批判性思维》 《世界是数字的》 《程序员的数学》 《程序员健康指南》 《禅与摩托车维修艺术》 《关键对话：如何高效能沟通》 《写作法宝：非虚构写作指南》 《黑客与画家 : 来自计算机时代的高见》 《软件随想录（卷1）》《软件随想录（卷2）》 《如何把事情做到最好：改变全球9800万人的人生指导书》","categories":[{"name":"其他","slug":"其他","permalink":"http://junjun.vip/categories/其他/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://junjun.vip/tags/书籍/"}]},{"title":"微信小程序4种常用的Flex布局模式","slug":"微信小程序Flex布局","date":"2019-07-05T16:00:00.000Z","updated":"2019-07-05T17:23:51.869Z","comments":true,"path":"2019/07/06/微信小程序Flex布局/","link":"","permalink":"http://junjun.vip/2019/07/06/微信小程序Flex布局/","excerpt":"","text":"官方建议的Flex布局 Flex的布局相比传统的float布局来说，简单、快捷、方便。掌握flex布局可以在制作微信小程序时减少wxss的代码，同时也符合微信小程序开发的文档要求 本代码中涉及到四种Flex的布局方式，分别使用了不同的flex的不同属性。建议看本文最后的学习参考进行相关属性的学习 骰子布局 骰子布局中主要强调几个属性的使用display justify-content align-items align-self等 1234567891011121314.first-face &#123; display: flex; justify-content: center; align-items: center;&#125;.second-face &#123; display: flex; justify-content: space-between;&#125;.second-pip-2 &#123; align-self: flex-end;&#125; 网格布局 主要依赖flex属性 123456.Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125; 百分比布局1234567.Grid &#123; display: flex;&#125;.cell-u-full &#123; flex: 0 0 100%;&#125; 流式布局123456789101112131415.parent &#123; width: 100%; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;&#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;&#125; Flex 学习参考 本代码参考阮一峰的网络日志:Flex 布局教程：实例篇编写 语法学习 阮一峰的网络日志:Flex 布局教程：语法篇","categories":[{"name":"小程序","slug":"小程序","permalink":"http://junjun.vip/categories/小程序/"}],"tags":[{"name":"flex布局","slug":"flex布局","permalink":"http://junjun.vip/tags/flex布局/"}]},{"title":"希尔排序","slug":"4.shellSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:32:59.542Z","comments":true,"path":"2019/07/05/4.shellSort/","link":"","permalink":"http://junjun.vip/2019/07/05/4.shellSort/","excerpt":"","text":"希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 1. 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2. JavaScript 代码实现123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 3. Python 代码实现12345678910111213141516def shellSort(arr): import math gap=1 while(gap &lt; len(arr)/3): gap = gap*3+1 while gap &gt; 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j &gt;=0 and arr[j] &gt; temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr&#125; 4. Go 代码实现1234567891011121314151617181920func shellSort(arr []int) []int &#123; length := len(arr) gap := 1 for gap &lt; gap/3 &#123; gap = gap*3 + 1 &#125; for gap &gt; 0 &#123; for i := gap; i &lt; length; i++ &#123; temp := arr[i] j := i - gap for j &gt;= 0 &amp;&amp; arr[j] &gt; temp &#123; arr[j+gap] = arr[j] j -= gap &#125; arr[j+gap] = temp &#125; gap = gap / 3 &#125; return arr&#125; 5. Java 代码实现12345678910111213141516171819202122232425262728public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 6. PHP 代码实现12345678910111213141516171819function shellSort($arr)&#123; $len = count($arr); $temp = 0; $gap = 1; while($gap &lt; $len / 3) &#123; $gap = $gap * 3 + 1; &#125; for ($gap; $gap &gt; 0; $gap = floor($gap / 3)) &#123; for ($i = $gap; $i &lt; $len; $i++) &#123; $temp = $arr[$i]; for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $temp; $j -= $gap) &#123; $arr[$j+$gap] = $arr[$j]; &#125; $arr[$j+$gap] = $temp; &#125; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"冒泡排序","slug":"1.bubbleSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:32:46.034Z","comments":true,"path":"2019/07/05/1.bubbleSort/","link":"","permalink":"http://junjun.vip/2019/07/05/1.bubbleSort/","excerpt":"","text":"冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 1. 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2. 动图演示![动图演示]/images/sort/bubbleSort.gif) 3. 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 4. 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 5. JavaScript 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 6. Python 代码实现123456def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr 7. Go 代码实现1234567891011func bubbleSort(arr []int) []int &#123; length := len(arr) for i := 0; i &lt; length; i++ &#123; for j := 0; j &lt; length-1-i; j++ &#123; if arr[j] &gt; arr[j+1] &#123; arr[j], arr[j+1] = arr[j+1], arr[j] &#125; &#125; &#125; return arr&#125; 8. Java 代码实现12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 9. PHP 代码实现1234567891011121314function bubbleSort($arr)&#123; $len = count($arr); for ($i = 0; $i &lt; $len - 1; $i++) &#123; for ($j = 0; $j &lt; $len - 1 - $i; $j++) &#123; if ($arr[$j] &gt; $arr[$j+1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $tmp; &#125; &#125; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"基数排序","slug":"10.radixSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:23.451Z","comments":true,"path":"2019/07/05/10.radixSort/","link":"","permalink":"http://junjun.vip/2019/07/05/10.radixSort/","excerpt":"","text":"基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1. 基数排序 vs 计数排序 vs 桶排序基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 2. LSD 基数排序动图演示 3. JavaScript 代码实现12345678910111213141516171819202122232425//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 4. Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 5. PHP 代码实现1234567891011121314151617181920212223242526272829303132function radixSort($arr, $maxDigit = null)&#123; if ($maxDigit === null) &#123; $maxDigit = max($arr); &#125; $counter = []; for ($i = 0; $i &lt; $maxDigit; $i++) &#123; for ($j = 0; $j &lt; count($arr); $j++) &#123; preg_match_all('/\\d/', (string) $arr[$j], $matches); $numArr = $matches[0]; $lenTmp = count($numArr); $bucket = array_key_exists($lenTmp - $i - 1, $numArr) ? intval($numArr[$lenTmp - $i - 1]) : 0; if (!array_key_exists($bucket, $counter)) &#123; $counter[$bucket] = []; &#125; $counter[$bucket][] = $arr[$j]; &#125; $pos = 0; for ($j = 0; $j &lt; count($counter); $j++) &#123; $value = null; if ($counter[$j] !== null) &#123; while (($value = array_shift($counter[$j])) !== null) &#123; $arr[$pos++] = $value; &#125; &#125; &#125; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"选择排序","slug":"2.selectionSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:32:50.333Z","comments":true,"path":"2019/07/05/2.selectionSort/","link":"","permalink":"http://junjun.vip/2019/07/05/2.selectionSort/","excerpt":"","text":"选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 1. 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2. 动图演示 3. JavaScript 代码实现12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 4. Python 代码实现1234567891011def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr 5. Go 代码实现12345678910111213func selectionSort(arr []int) []int &#123; length := len(arr) for i := 0; i &lt; length-1; i++ &#123; min := i for j := i + 1; j &lt; length; j++ &#123; if arr[min] &gt; arr[j] &#123; min = j &#125; &#125; arr[i], arr[min] = arr[min], arr[i] &#125; return arr&#125; 6. Java 代码实现1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 7. PHP 代码实现12345678910111213141516function selectionSort($arr)&#123; $len = count($arr); for ($i = 0; $i &lt; $len - 1; $i++) &#123; $minIndex = $i; for ($j = $i + 1; $j &lt; $len; $j++) &#123; if ($arr[$j] &lt; $arr[$minIndex]) &#123; $minIndex = $j; &#125; &#125; $temp = $arr[$i]; $arr[$i] = $arr[$minIndex]; $arr[$minIndex] = $temp; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"插入排序","slug":"3.insertionSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:32:54.039Z","comments":true,"path":"2019/07/05/3.insertionSort/","link":"","permalink":"http://junjun.vip/2019/07/05/3.insertionSort/","excerpt":"","text":"插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 1. 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2. 动图演示 3. JavaScript 代码实现1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 4. Python 代码实现123456789def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex &gt;= 0 and arr[preIndex] &gt; current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr 5. Go 代码实现123456789101112func insertionSort(arr []int) []int &#123; for i := range arr &#123; preIndex := i - 1 current := arr[i] for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current &#123; arr[preIndex+1] = arr[preIndex] preIndex -= 1 &#125; arr[preIndex+1] = current &#125; return arr&#125; 6. Java 代码实现1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 7. PHP 代码实现1234567891011121314function insertionSort($arr)&#123; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; $preIndex = $i - 1; $current = $arr[$i]; while($preIndex &gt;= 0 &amp;&amp; $arr[$preIndex] &gt; $current) &#123; $arr[$preIndex+1] = $arr[$preIndex]; $preIndex--; &#125; $arr[$preIndex+1] = $current; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"桶排序","slug":"9.bucketSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:19.751Z","comments":true,"path":"2019/07/05/9.bucketSort/","link":"","permalink":"http://junjun.vip/2019/07/05/9.bucketSort/","excerpt":"","text":"桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 1. 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 2. 什么时候最慢当输入的数据被分配到了同一个桶中。 3. JavaScript 代码实现12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 4. Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 5. PHP 代码实现12345678910111213141516171819202122232425262728293031323334353637function bucketSort($arr, $bucketSize = 5)&#123; if (count($arr) === 0) &#123; return $arr; &#125; $minValue = $arr[0]; $maxValue = $arr[0]; for ($i = 1; $i &lt; count($arr); $i++) &#123; if ($arr[$i] &lt; $minValue) &#123; $minValue = $arr[$i]; &#125; else if ($arr[$i] &gt; $maxValue) &#123; $maxValue = $arr[$i]; &#125; &#125; $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1; $buckets = array(); for ($i = 0; $i &lt; count($buckets); $i++) &#123; $buckets[$i] = []; &#125; for ($i = 0; $i &lt; count($arr); $i++) &#123; $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i]; &#125; $arr = array(); for ($i = 0; $i &lt; count($buckets); $i++) &#123; $bucketTmp = $buckets[$i]; sort($bucketTmp); for ($j = 0; $j &lt; count($bucketTmp); $j++) &#123; $arr[] = $bucketTmp[$j]; &#125; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"归并排序","slug":"5.mergeSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:03.088Z","comments":true,"path":"2019/07/05/5.mergeSort/","link":"","permalink":"http://junjun.vip/2019/07/05/5.mergeSort/","excerpt":"","text":"归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 2. 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 3. 动图演示 4. JavaScript 代码实现12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 5. Python 代码实现1234567891011121314151617181920def mergeSort(arr): import math if(len(arr)&lt;2): return arr middle = math.floor(len(arr)/2) left, right = arr[0:middle], arr[middle:] return merge(mergeSort(left), mergeSort(right))def merge(left,right): result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)); else: result.append(right.pop(0)); while left: result.append(left.pop(0)); while right: result.append(right.pop(0)); return result 6. Go 代码实现1234567891011121314151617181920212223242526272829303132333435func mergeSort(arr []int) []int &#123; length := len(arr) if length &lt; 2 &#123; return arr &#125; middle := length / 2 left := arr[0:middle] right := arr[middle:] return merge(mergeSort(left), mergeSort(right))&#125;func merge(left []int, right []int) []int &#123; var result []int for len(left) != 0 &amp;&amp; len(right) != 0 &#123; if left[0] &lt;= right[0] &#123; result = append(result, left[0]) left = left[1:] &#125; else &#123; result = append(result, right[0]) right = right[1:] &#125; &#125; for len(left) != 0 &#123; result = append(result, left[0]) left = left[1:] &#125; for len(right) != 0 &#123; result = append(result, right[0]) right = right[1:] &#125; return result&#125; 7. Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 8. PHP 代码实现1234567891011121314151617181920212223242526272829303132function mergeSort($arr)&#123; $len = count($arr); if ($len &lt; 2) &#123; return $arr; &#125; $middle = floor($len / 2); $left = array_slice($arr, 0, $middle); $right = array_slice($arr, $middle); return merge(mergeSort($left), mergeSort($right));&#125;function merge($left, $right)&#123; $result = []; while (count($left) &gt; 0 &amp;&amp; count($right) &gt; 0) &#123; if ($left[0] &lt;= $right[0]) &#123; $result[] = array_shift($left); &#125; else &#123; $result[] = array_shift($right); &#125; &#125; while (count($left)) $result[] = array_shift($left); while (count($right)) $result[] = array_shift($right); return $result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"快速排序","slug":"6.quickSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:06.652Z","comments":true,"path":"2019/07/05/6.quickSort/","link":"","permalink":"http://junjun.vip/2019/07/05/6.quickSort/","excerpt":"","text":"快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 1. 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 2. 动图演示 3. JavaScript 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function partition2(arr, low, high) &#123; let pivot = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123; --high; &#125; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123; ++low; &#125; arr[high] = arr[low]; &#125; arr[low] = pivot; return low;&#125;function quickSort2(arr, low, high) &#123; if (low &lt; high) &#123; let pivot = partition2(arr, low, high); quickSort2(arr, low, pivot - 1); quickSort2(arr, pivot + 1, high); &#125; return arr;&#125; 4. Python 代码实现1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] 5. Go 代码实现123456789101112131415161718192021222324252627282930func quickSort(arr []int) []int &#123; return _quickSort(arr, 0, len(arr)-1)&#125;func _quickSort(arr []int, left, right int) []int &#123; if left &lt; right &#123; partitionIndex := partition(arr, left, right) _quickSort(arr, left, partitionIndex-1) _quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;func partition(arr []int, left, right int) int &#123; pivot := left index := pivot + 1 for i := index; i &lt;= right; i++ &#123; if arr[i] &lt; arr[pivot] &#123; swap(arr, i, index) index += 1 &#125; &#125; swap(arr, pivot, index-1) return index - 1&#125;func swap(arr []int, i, j int) &#123; arr[i], arr[j] = arr[j], arr[i]&#125; 6. C++版12345678910111213141516171819202122232425//严蔚敏《数据结构》标准分割函数Paritition1(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; --high; &#125; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;void QuickSort(int A[], int low, int high) //快排母函数&#123; if (low &lt; high) &#123; int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); &#125;&#125; 7. Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 8. PHP 代码实现1234567891011121314151617181920function quickSort($arr)&#123; if (count($arr) &lt;= 1) return $arr; $middle = $arr[0]; $leftArray = array(); $rightArray = array(); for ($i = 1; $i &lt; count($arr); $i++) &#123; if ($arr[$i] &gt; $middle) $rightArray[] = $arr[$i]; else $leftArray[] = $arr[$i]; &#125; $leftArray = quickSort($leftArray); $leftArray[] = $middle; $rightArray = quickSort($rightArray); return array_merge($leftArray, $rightArray);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"堆排序","slug":"7.heapSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:11.862Z","comments":true,"path":"2019/07/05/7.heapSort/","link":"","permalink":"http://junjun.vip/2019/07/05/7.heapSort/","excerpt":"","text":"堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 1. 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 2. 动图演示 3. JavaScript 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; 4. Python 代码实现123456789101112131415161718192021222324252627282930def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i)def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left &lt; arrLen and arr[left] &gt; arr[largest]: largest = left if right &lt; arrLen and arr[right] &gt; arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest)def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i]def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr 5. Go 代码实现123456789101112131415161718192021222324252627282930313233343536func heapSort(arr []int) []int &#123; arrLen := len(arr) buildMaxHeap(arr, arrLen) for i := arrLen - 1; i &gt;= 0; i-- &#123; swap(arr, 0, i) arrLen -= 1 heapify(arr, 0, arrLen) &#125; return arr&#125;func buildMaxHeap(arr []int, arrLen int) &#123; for i := arrLen / 2; i &gt;= 0; i-- &#123; heapify(arr, i, arrLen) &#125;&#125;func heapify(arr []int, i, arrLen int) &#123; left := 2*i + 1 right := 2*i + 2 largest := i if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] &#123; largest = left &#125; if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] &#123; largest = right &#125; if largest != i &#123; swap(arr, i, largest) heapify(arr, largest, arrLen) &#125;&#125;func swap(arr []int, i, j int) &#123; arr[i], arr[j] = arr[j], arr[i]&#125; 6. Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 7. PHP 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function buildMaxHeap(&amp;$arr)&#123; global $len; for ($i = floor($len/2); $i &gt;= 0; $i--) &#123; heapify($arr, $i); &#125;&#125;function heapify(&amp;$arr, $i)&#123; global $len; $left = 2 * $i + 1; $right = 2 * $i + 2; $largest = $i; if ($left &lt; $len &amp;&amp; $arr[$left] &gt; $arr[$largest]) &#123; $largest = $left; &#125; if ($right &lt; $len &amp;&amp; $arr[$right] &gt; $arr[$largest]) &#123; $largest = $right; &#125; if ($largest != $i) &#123; swap($arr, $i, $largest); heapify($arr, $largest); &#125;&#125;function swap(&amp;$arr, $i, $j)&#123; $temp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $temp;&#125;function heapSort($arr) &#123; global $len; $len = count($arr); buildMaxHeap($arr); for ($i = count($arr) - 1; $i &gt; 0; $i--) &#123; swap($arr, 0, $i); $len--; heapify($arr, 0); &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"计数排序","slug":"8.countingSort","date":"2019-07-04T16:00:00.000Z","updated":"2019-07-05T17:33:16.101Z","comments":true,"path":"2019/07/05/8.countingSort/","link":"","permalink":"http://junjun.vip/2019/07/05/8.countingSort/","excerpt":"","text":"计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 1. 动图演示 2. JavaScript 代码实现12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 3. Python 代码实现123456789101112131415def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 4. Go 代码实现123456789101112131415161718192021func countingSort(arr []int, maxValue int) []int &#123; bucketLen := maxValue + 1 bucket := make([]int, bucketLen) // 初始为0的数组 sortedIndex := 0 length := len(arr) for i := 0; i &lt; length; i++ &#123; bucket[arr[i]] += 1 &#125; for j := 0; j &lt; bucketLen; j++ &#123; for bucket[j] &gt; 0 &#123; arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 &#125; &#125; return arr&#125; 5. Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 6. PHP 代码实现123456789101112131415161718192021222324function countingSort($arr, $maxValue = null)&#123; if ($maxValue === null) &#123; $maxValue = max($arr); &#125; for ($m = 0; $m &lt; $maxValue + 1; $m++) &#123; $bucket[] = null; &#125; $arrLen = count($arr); for ($i = 0; $i &lt; $arrLen; $i++) &#123; if (!array_key_exists($arr[$i], $bucket)) &#123; $bucket[$arr[$i]] = 0; &#125; $bucket[$arr[$i]]++; &#125; $sortedIndex = 0; foreach ($bucket as $key =&gt; $len) &#123; if ($len !== null) $arr[$sortedIndex++] = $key; &#125; return $arr;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"十大经典排序算法","slug":"十大经典排序算法","date":"2019-07-03T16:00:00.000Z","updated":"2019-07-05T17:31:09.037Z","comments":true,"path":"2019/07/04/十大经典排序算法/","link":"","permalink":"http://junjun.vip/2019/07/04/十大经典排序算法/","excerpt":"","text":"排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 GitBook 内容大纲 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序 本书内容几乎完全来源于网络。 开源项目地址：https://github.com/hustcc/JS-Sorting-Algorithm，整理人 hustcc。 GitBook 在线阅读地址：https://sort.hust.cc/。 本项目使用 lint-md 进行中文 Markdown 文件的格式检查，务必在提交 Pr 之前，保证 Markdown 格式正确。","categories":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://junjun.vip/tags/算法/"}]},{"title":"hexo主题pure使用教程","slug":"hexo-pure","date":"2019-07-02T16:00:00.000Z","updated":"2019-07-05T08:36:03.017Z","comments":true,"path":"2019/07/03/hexo-pure/","link":"","permalink":"http://junjun.vip/2019/07/03/hexo-pure/","excerpt":"","text":"pureA brand new default theme for [Hexo]. Preview | English documentation | iconfont 特色 多语言 第三方评论框（友言、来必力、gitment、gitalk） 可展示个人豆瓣书单 可展示个人github托管项目 可设置支付宝、微信打赏 主题颜色 页面展示首页 | 归档 | 分类 | 标签 | 项目 | 书单 | 友链 | 关于 配置说明在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件 安装主题1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题12cd themes/puregit pull 启用pure主题打开站点配置文件，找到theme字段，将其值更改为 pure 1theme: pure 到此，主题安装完成。然后启动Hexo服务验证主题是否正确启用。 1hexo s 安装插件hexo-wordcount1npm install hexo-wordcount --save hexo-generator-json-content1npm install hexo-generator-json-content --save hexo-generator-feed1npm install hexo-generator-feed --save hexo-generator-sitemap1npm install hexo-generator-sitemap --save hexo-generator-baidu-sitemap1npm install hexo-generator-baidu-sitemap --save 主题配置设置语言打开站点配置文件, 将 language 设置成你所需要的语言。建议明确设置你所需要的语言,可选值对应themes\\pure\\languages目录下语言文件，简体中文配置如下： 1language: zh-CN 主题颜色定制了五套颜色，默认白，黑:theme-black，蓝:theme-blue，绿:theme-green，紫:theme-purple 123# configconfig: skin: # 主题颜色 theme-black theme-blue theme-green theme-purple 导航菜单12345678910111213141516171819202122# 导航菜单menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 书单 Links: links # 友链 About: about # 关于# 导航菜单图标（font awesome）menu_icons: enable: true # 是否启用菜单图标 home: icon-home-fill archives: icon-archives-fill categories: icon-folder tags: icon-tags repository: icon-project books: icon-book-fill links: icon-friendship about: icon-cup-fill 设置个人信息123头像在themes\\pure\\source\\images 目录下替换图片即可，捐献的二维码同理。个人信息大部分都在 主题配置文件 中设置 搜索主题内置三种站内搜索方式：insight、swiftype、baidu 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search 分享支持weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedin 123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: true # 是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标 评论主题集成了disqus、友言、来必力、gitment、gitalk评论系统，选择其中一种即可 12345678910111213141516# Comment# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/comment: type: livere # 启用哪种评论系统 disqus: # enter disqus shortname here youyan: uid: *** # enter youyan uid livere: uid: *** # enter livere uid gitment: githubID: username repo: username.github.io ClientID: *** ClientSecret: *** lazy: false 文章浏览量统计主题内置了不蒜子和leancloud来统计文章浏览量，启用其中之一即可，注意leancloud需要到其官网申请APP ID 和APP Key。 比如，启用不蒜子来统计文章浏览量，在主题配置文件中把busuanzi设置为true即可： 123pv: busuanzi: enable: true # 不蒜子统计 如果不需要第三方来统计浏览量，只需将相应设置改为false即可（设置为false后不会加载第三方JS脚本） Github respostory复制theme/pure/_source/ 目录下repository文件夹到blog path/source/ 目录下 123# Githubgithub: username: *** # github username 豆瓣书单复制theme/pure/_source/ 目录下books文件夹到blog path/source/ 目录下 12345# douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数 友情链接复制theme/pure/_source/ 目录下links文件夹到blog path/source/ 目录下 在 hexo 目录下的 source 文件夹内创建一个名为 _data（禁止改名）的文件夹。 然后在文件内创建一个名为 links.yml 的文件,在其中添加相关数据即可。 单个友情链接的格式为： 1234Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot; 添加多个友情链接，我们只需要根据上面的格式重复填写即可。 . 将 Name 改为友情链接的名字，例如 Cofess。 . http://example.com 为友情链接的地址。 . http://example.com/avatar.png 为友情链接的头像。 . 这是一个描述 为友情链接描述。 文章索引目录123456title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引 sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可： 123456title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用 博客优化hexo-neat auto Minify html、js、css and make it neat 1npm install hexo-neat --save 在博客配置文件_config.yml中添加 12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; hexo-baidu-url-submit1npm install hexo-baidu-url-submit --save hexo-translate-title 使用Google翻译，百度翻译和有道翻译将Hexo中的汉字标题转成英文标题 安装 1npm install hexo-translate-title --save 在博客配置文件_config.yml中添加 123456translate_title: translate_way: google #google | baidu | youdao youdao_api_key: XXX youdao_keyfrom: XXX is_need_proxy: true #true | false proxy_url: http://localhost:8123 注意：判断是否需要配置google本地代理，因为我在本地是开启时才能访问google翻译的，如果没有被墙，请将_config.yml 下的is_need_proxy: true改为false。如果设置为true,请设置本地代理地址 数学公式 Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签 解决方案解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的方法。 更换Hexo的markdown渲染引擎，hexo-renderer-markdown-it-plus引擎替换默认的渲染引擎hexo-renderer-marked即可。 安装hexo-renderer-markdown-it-plus插件12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save 配置安装插件后，如果未正常渲染LaTeX数学公式，在博客配置文件_config.yml中添加 12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false 文章启用mathjax12title: Hello Worldmathjax: true","categories":[{"name":"hexo","slug":"hexo","permalink":"http://junjun.vip/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://junjun.vip/tags/hexo/"}]},{"title":"hexo命令","slug":"hello-world","date":"2019-07-02T16:00:00.000Z","updated":"2019-07-05T08:35:52.485Z","comments":true,"path":"2019/07/03/hello-world/","link":"","permalink":"http://junjun.vip/2019/07/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://junjun.vip/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://junjun.vip/tags/hexo/"}]}]}